version: '3.8'

services:
  attacker:
    build: ./attacker
    volumes:
      - ./attacker/scripts:/attacker_files
    container_name: attacker-container
    networks:
      test-network:
        ipv4_address: 172.30.0.7
    privileged: true
    tty: true
    environment:
      - TARGET_IP=172.30.0.2
    depends_on:
      - golang-ips
    
  attacker1:
    build: ./attacker
    volumes:
      - ./attacker/scripts:/attacker_files
    container_name: attacker-container1
    networks:
      test-network:
        ipv4_address: 172.30.0.8
    privileged: true
    tty: true
    environment:
      - TARGET_IP=172.30.0.2
    depends_on:
      - golang-ips

  attacker2:
    build: ./attacker
    volumes:
      - ./attacker/scripts:/attacker_files
    container_name: attacker-container2
    networks:
      test-network:
        ipv4_address: 172.30.0.9
    privileged: true
    tty: true
    environment:
      - TARGET_IP=172.30.0.2
    depends_on:
      - golang-ips


  python-server:
    build:
      context: ./AIModels  # Directory containing your Python server code
    container_name: python-server-container
    networks:
      test-network:
        ipv4_address: 172.30.0.11
    volumes:
      - ./AIModels:/app
    depends_on:
      - golang-ips  # Ensures Golang service is up before the Python server starts
    privileged: true
    tty: true

      
  golang-ips:
    build: .
    container_name: golang-ips
    volumes:
      - .:/app
    environment:
      - AIR_WATCH_DIR=/app
    networks:
      test-network:
        ipv4_address: 172.30.0.2
    privileged: true
    tty: true
    dns:
      - 172.30.0.3  # The DNS server for this container
  dns-server:
    image: technitium/dns-server:latest
    container_name: dns-server
    networks:
      test-network:
        ipv4_address: 172.30.0.3
    restart: unless-stopped

networks:
  test-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.30.0.0/24
